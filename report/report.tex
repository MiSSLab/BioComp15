\documentclass[a4paper,10pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage[utf8]{inputenc}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.0cm]{geometry}
\usepackage{multirow}
\usepackage{geometry}
\usepackage{pdflscape}
\usepackage{xcolor}
\usepackage{listings}
\lstset{basicstyle=\ttfamily,
  showstringspaces=false,
  commentstyle=\color{red},
  keywordstyle=\color{blue}
}

\newcommand{\xmark}{\ding{55}}%


\title{Elements of Computational Biology\\ \Large
Subject 15: Distance phylogenetics: UPGMA and NJ}
\author{Agata Radys, Paweł Cejrowski, Łukasz Myśliński}
\date{\today}

\begin{document}
\newgeometry{margin=1.8cm}
\maketitle

\section{Algorithms}

\subsection{UPGMA (ang. Unweighted Pair Group Method with Arithmetic Mean)}
Data: ultrametric matrix \textit{d} for set \textit{L}.
\begin{lstlisting}[caption={UPGMA pseudocode}]
clusters[|L|]
while (clusters.length > 1):
    calculate distances between clusters
        (sum of distances between cluster members
            divided by product of cluster cardinalities)
    find the lowest distance
    merge the closest clusters
\end{lstlisting}

\subsection{NJ}
Data: ultrametric matrix \textit{d} for set \textit{L}.\\ \\
Q - matrix: $ Q(i,j) = (n-2)d(i,j) - \sum_{k=1}^{n} d(i,k) - \sum_{k=1}^{n} d(j,k)$ \\ \\
Distance from the pair members to the new node: \\ \\
$d'(f,u) = \frac{1}{2}d(f,g) + \frac{1}{2(n-2)}(\sum_{k=1}^n d(f,k) - \sum_{k=1}^n d(g,k))$ \\ \\
$d(g,u) = d(f,g) - d'(f,u)$

\subsection{Creaing adjacency matrix}
Both rooted and unrooted trees created via UPGMA and NJ algorithms can be transformed to adjacency matrix. The algorithm for that is as follows:
\begin{lstlisting}[caption={Tree to adjacency matrix.}]
function walk(Node rootNode):
    int x = adjacencyMatrix.establishPosition(rootNode)
    for (node : rootNode.getChildren ):
        int y = adjacencyMatrix.establishPosition(node)
        adjacencyMatrix[x][y] = 1;
        adjacencyMatrix[y][x] = 1;
        walk(node);

init adjacency matrix with 0;
walk(tree.rootNode)
\end{lstlisting}

\subsection{Creating canonical tree}
To compare trees, we need its canonical form. It will be a tree with the first node from input data as a root.
\begin{lstlisting}[caption={Tree to adjacency matrix.}]
function toCanonicalTree:
    List<Integer> visited = new ArrayList<>();
    Node rootNode = createNodes(0, visited);
    return new Tree(rootNode);

function Node createNodes(int i, List<Integer> visited):
    visited.add(i);
    Node node = new Node(adjacencyMatrix.header[i]);
    for (j = 0; j < adjacencyMatrix.header.length; j++):
        if (visited.notContains(j) && adjacencyMatrix[i][j] = 1):
            node.children.add(createNodes(j, visited));
    return node;
\end{lstlisting}

\subsection{Tree comparison}
Trees in canonical form can be easily compared using the following algorithm.
\begin{lstlisting}[caption={Comparing trees.}]
function equals(Node aNode, Node bNode):
    if (aNode.children.size = bNode.children.size):
        if (aNode.children.size == 0 && .children.size  == 0) {
            if (aNode.label = bNode.label) {
                return true
            else:
                return false
        else:
            comparisons = []
            for (aChild : aNode.children):
                comparisons2 = []
                for (bChild : bNode.children):
                    boolean equals = equals(aChild, bChild)
                    comparisons2.add(equals)
                comparisons.add(comparisons2.reduce(or))
            return comparisons.reduce(and)
    else:
        return false;
\end{lstlisting}
An important assumption in this algorithm is that we can compare labels of leaf-nodes, because they are those given as an input so they have to be equal.

\begin{lstlisting}[caption={NJ pseudocode}]
clusters[|L|]
while (number of clusters > 2):
    calculate Q-matrix
    find the lowest q-distance
    merge the q-closest clusters
    update distances
merge last 2 clusters
\end{lstlisting}


\subsection{Comparing topology}

\section{Usage}
Program was developed in Java programming language without any external libraries. All sources are available on Github and compiled using \texttt{Maven}.
\begin{lstlisting}[language=bash,caption={Building project}]
git clone git@github.com:MiSSLab/BioComp15.git
mvn package
\end{lstlisting}
Created Java archive can be run using \texttt{JRE}. Sample data can be found in directory \texttt{resources/}.
\begin{lstlisting}[language=bash,caption={Running project using data1.matrix}]
java -jar -Dfilename="resources/data1.matrix" \
    target/distance-phylogenetics-jar-with-dependencies.jar
\end{lstlisting}

\section{Data formats}
\subsection{Input}
Application requires \texttt{CSV} data format and quadratic matrix of distances.

\begin{lstlisting}[caption={Example data file content}]
a,b,c,d,e
0,8,8,5,3
8,0,3,8,8
8,3,0,8,8
5,8,8,0,5
3,8,8,5,0
\end{lstlisting}
Labels in header has to be lexicographically sorted, dense vector with every column matching \texttt{"[a-z]+"}.
\subsection{Output}
Resulting trees are printed in \texttt{ASCII}-art to the \texttt{STDOUT}.
\begin{lstlisting}[caption={UPGMA output}]
UPGMA(resources/data2.matrix)
[[33.0]]
|-[[28.0]]
|  |---- [[c]]
|  `---- [[d]]
`-[[22.0]]
   |-[[17.0]]
   |  |---- [[a]]
   |  `---- [[b]]
   `---- [[e]]
\end{lstlisting}

Despite the fact that NJ returns unrooted tree it is presented as a rooted one with particular node choosen as a root.
\begin{lstlisting}[caption={NJ output}]
NJ(resources/data2.matrix)
[[g]]
|---- [4.75-<-[a]]
|-[7.25-<-[f]]
|  |---- [11.0-<-[c]]
|  `---- [17.0-<-[d]]
`-[4.75-<-[h]]
   |---- [6.75-<-[b]]
   `---- [14.25-<-[e]]
\end{lstlisting}

\end{document}

